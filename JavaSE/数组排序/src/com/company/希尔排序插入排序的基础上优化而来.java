package com.company;
/*

 * 希尔排序（插入类）

 * Shell排序法是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。

 * 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

 * 	按增量序列个数k，对序列进行k 趟排序；

 * 	每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。

 * 	仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

 *

 * @param d 定义的初始增量

 */
/*
希尔排序是在插入排序的基础上优化而来的，
适用于：对于直接插入排序问题，数据量巨大时(间隔排序，   直到间隔为1，最后间隔为1，直接就是直接插入排序)
原理就是将一个数组按一定间隔分割成若干个小区间，针对每个区间使用插入排序。
当各个区间都有序时再针对整体进行插入排序。这样整个数组就是有序的，而且效率很高。
也称为缩小增量排序，它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

如何写成代码：
首先确定分的组数。
然后对组中元素进行插入排序。
然后将length/2，重复1,2步，直到length=0为止。
1、基本思想：
希尔排序也成为“缩小增量排序”，其基本原理是，现将待排序的数组元素分成多个子序列，使得每个子序列的元素个数相对较少，
然后对各个子序列分别进行直接插入排序，待整个待排序列“基本有序”后，最后在对所有元素进行一次直接插入排序。
因此，我们要采用跳跃分割的策略将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。
希尔排序是对直接插入排序算法的优化和升级。
所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，

希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式移动，使得排序的效率提高。
需要注意的是，增量序列的最后一个增量值必须等于1才行。另外，由于记录是跳跃式的移动，希尔排序并不是一种稳定的排序算法。
 */

public class 希尔排序插入排序的基础上优化而来 {
    public static void main(String[] args) {
        int[] arr={4,2,5,1,3,6,9,8,7};
        //对数组进行希尔排序
           ShellSort(arr);
           //遍历数组，并将其输出
           printArray(arr);
    }
    public static int[] ShellSort(int[] arr) {
        int  gap = arr.length / 2; //gap为增量
        while (gap > 0) {    //gap为1时直接进行直接插入排序
            for (int i = gap; i < arr.length; i++) {
               int temp = arr[i];

               //arr[i]=arr[i - gap]
                while ( (i - gap) >= 0&& arr[i - gap] > temp) {//当分的两个子序列中后面的元素temp=arr[i]比前面的元素arr[i-gap]小时，将两个数换位置
                    //元素索引-增量必须大于或0，并且temp这个元素必须比他前面距离他gap个索引的元素要小，然后将两者进行交换
                    arr[i] = arr[i - gap];//按增量比较，谁小换到前面，按照增量比较   arr[i-gap]  间距为gap个元素   arr[x]
                    i=i-gap;//没词让其与它和它间隔增量个数组元素进行比较
                }

                arr[i] = temp;
            }
            gap /= 2;
        }
        return arr;
    }
    //遍历数组功能
    public static void printArray(int[] arr){
        System.out.print("[");
        for(int x=0;x<arr.length;x++){
            if(x==arr.length-1){
                System.out.println(arr[x]+"]");
            }else{
                System.out.print(arr[x]+", ");
            }
        }
    }

}

















