package com.company;
/*
我们观察上面两个代码:
发现name，age成员变量，以及getXxx () /setXxx (),还有eat ()等都是相同的。
如果我们后来继续定义类。举例工人类，军人类。他们是不是也具备这些内容
那么我们每一次定义这样的类的时候都要把这些重复的内容都重新定义一遍。
麻烦不?麻烦所以我们要考虑改进?如何改进呢?
我这想的我能不能把这些相同的内容给定义到一个独立的类虫
然后，让这多个类和这个独立的类产生一个关系有了这个关系后is a 关系
这多个类就可以具备这个独立的类的功能。
为了实现这个效果，java就提供了一个技术 继承。
继承怎么表示呢?继承的格式是什么梯子的呢?
class Fu { }
class Zi extends Fu {
}
好处:
    A:提高了代码的复用性
    B:提高了代码的維护性
    c:让类与类之间产生了关系是多态的前提
类与类产生了关系其实也是继承的一个鱉端:
        类的耦合性增强了
        开发的原则低耦合，高内聚
        耦合：类与类的关系
        内聚:就是自己完成基件事情的能力
继承的注意事项：
    A:子类只能继承父类所有非私有的成员(成员方法和成员变量)
    B:子类不能继承父类的构造方法但是可以通过super关键字去访问父类构造方法
    C:不要为了部分功能而去继承
那么我们什么时候考虑使用继承呢?
       继承其实体现的是一种关系"is a"
        Person：（is a）
                 Student
                 Teacher
采用假设法。
如果有两个类A,B。只有他们符合A是B的-种，或者B是A的一种，就可以考虑使用继承。
@问题是:
我不仅仅要输出局部范围的num还要输出本类成员范围的num怎众办呢?
我还想要输出父类成员范围的num怎么办呢?
如果有一个东西和this相似但是可以直接访问父类的数据就好了
恭喜你这个关键字是存在的：super
this和supex的区别?
分别是什众呢?
      this代表本类对应的引用。
      super代表父类存储空间的标识(可以理解为父类引用，可以操作父类的成员)
怎众用呢?
A:调用成员变量
    this.成员变量调用本类的成员变量
    super.成员变量调用父类的成员变量
B:调用构造方法
    this(...)  调用本类的构造方法
    super(. . .)  调用父类的构造方法
C:调用成员方法
    this.成员方法调用本类的成员方法
    super.成员方法调用父类的成员方法
继承中构造方法的关系
     A:子类中所有的构造方法默认都会访问父类中空参数的构造方法
     B:为什么呢?
       因为子类会继承父类中的数据，可能还会使用父类的数据
       所以子类初始化之前.-定要先完成父类数据的初始化
     注意:子类每一个构造方法的第一条语句默认都是super();
如果父类没有无参构造方法那么子类的构造方法会出现什么现象呢?
报错.
如何解决呢?
     A:在父类中加一个无参构造方法
     B:通过使用super关键字去显示的调用父类的带参构造方法
     c:子类通过this去调用本类的其他构造方法
     子类中一定要有一个去访问了父类的构造方法否则父类数据就没有初始化
     注意事项，
       this(...)或者super(...)必须出现在第一条语旬上
    如果不是放在第条语包上就可能对父类的数据进行了多次初始化所以必须放在第一条语句上
C:子父类的初始化(分层初始保)
   先进行父类初始化然后进行子类初始化em.
问题:
      虽然子类中构造方法默认有-个super ()
      初始化的时候不是按照那个顺序进行的
      而是按照分层初始化进行的
      它仅仅表示要先初始化父类数据，再初始化子类数据。
   @子类中的方法和父类中的方法声明一样，这个该怎么玩呢? .
       通过子类调用方法：
          a:先找子类中看有没有这个方法有就使用
          b:再看父类中有没有这个方法有就使用
          c:如果没有就报错。
   @●方法重写概述
      子类中出现了和父类中一模一样的方法声明，也被称为方法覆盖，方法复写。
      使用特点:
           ●如果方法名不同，就调用对应的方法
           ●如果方法名相同，最终使用的是子类自己的
      ●方法重写的应用:
        当子类需要父类的功能，而功能主体子类有自己特有
        内容时，可以重写父类中的方法，这样，即沿袭了父
        类的功能，又定义了子类特有的内容。
方法重写的注意事项：
     A:父类中私有方法不能被重写，因为父类私有方法子类根本就无法继承
     B:子类重写父类方法时访问权限不能更低，最好就-致
     c:父类静态方法子类也必须通过静态方法进行重写
       其实这个算不上方法重写，但是现象确实如此至于为什么算不上方法重写多态中我会进解
      子类重写父类方法的时候最好声明模一样。
1:方法重写和方法重载的区别?方法重载能改变返回值类型吗?
    方法重写:（Override）
         在子类中出现和父类中模一样的方法声明的现象
    方法重载:（Overload）
         同一个类中出现的方法名相同，参数烈表不同的现象
         方法重载能改变返回值类型，因为它和返回值类型无关。
2: this关键字和super关键字分别代表什么?以及他们各自的使用场景和作用？
   this:代表当前类的对象引用
   super:代表父类存储空间的标识
         (可以理解为父类的引用通过这个东西可以访间父类的成员)
   场景:
      成员变量:
             this.成员变量
             super.成员变量
      构造方法:
             this(...)
             super(. . .)
      成员方法:
             this.成员方法
             super.成员方法
@final
  由于继承中方法有个现象：方法重写，所以父类的功能，就会被子类给覆盖调
有些时候，我们不想让子类去覆盖掉父类的功能，只能让他使用
这个时候，针对这种情况，Java就提供 了一个关键字: final
final:最終的意思常见的是它可以修饰类，方法。变量
特点:
      fina1可以修饰类，该类不能被继承。
      final可以絛饰方法.该方法不能被重写. (覆盖，复写)
      final可以修饰变量，该变量不能被重新赋值因为这个变量其实常量
     常量:
         A:字面值常量   "hello", 10, true
         B:自定义常量     final int X = 10;
@面试题:. final絛饰局部变量的问题
     基本类型：基本类型的值不能发生改变。
     引用类型：引用类型的地址值不能发生改变，但是该对象的堆内存的值是可以改变的
      final修饰变量的初始化时机
          A:被final絛饰的变量只能赋值一次。
          B:在构造方法完毕前(非静态的常量)















 */

public class Main {

    public static void main(String[] args) {
	// write your code here
    }
}
