package com.company;
/*
狗看门，猫一般就是宠物--》现在有很多驯养员可以训练出，猫钻火圈，狗跳高
--》这些额外的动作，并不是所有的猫或者狗一开始就具备的，是经过特殊的培训出来的，
所以将这些额外的功能定义到动物类中不合适，动物类中定义的是共性的东西，是一开始就有的，而这是额外的东西，按照继承的思想，把这定义在父亲里是有问题的，
它也不适合直接定义在猫或狗中，因为不是所有的猫都这样，不是所有的狗都这样，因为只有部分猫狗才具有这些功能，
--》如何把这些额外的东西定义出来？
--》为了体现事物的扩展性，java提供了接口来定义这些额外功能，并不给出具体实现（抽象方法），将来哪些猫、狗需要被培训，只需要这部分猫狗把这些额外功能实现即可
（接口的功能--》额外扩展的功能）
接口的特点：
  A:接口用关键字interface表示
    interface 接口名{}
  B:类实现接口用implements表示
    class类名implements接口名{}
  C:接口不能实例化
    那么接口如何实例化呢?
    按照多态的方式来实例化
  D:接口的子类
    a:可以是抽象类。但是意义不太
    b:可以是具体类，要重写接口中的所有抽象方法。(推荐方案)
由此可见:
  A:具体类多态(几乎没有)
  B:抽象类多态(常用)
  C:接只多态(最常用)
接口名+Impl 这种格式是接口的实现类格式
//接口方法不能带有主体？：
//接口最大的作用是作为一种协议，实现接口的一方提供功能，而使用接口的一方只要去调用接口中定义的方法就行了，
//至于具体的实现则由实现方去实现。起到了声明和实现分离，如果没有接口，所有都是直接的类与类之间的访问与调用，
//则会导致耦合性过高，不利于扩展。因为接口是用来标明方法调用的。在程序里调用接口，只调用方法就可以，不用关心方法是如何实现的
//，将来实现接口的类如何调整都不会影响到调用者。如果上来直接就调用具体方法，
//将来这个具体方法换掉的时候你不是就木了吗，也许就要改好几个类了。
//用术语说叫提高了耦合性（耦合性就是可以理解为粘连性，依赖性，因为往往一个项目的代码编程量是很大的，
//所以这个就要注意每段程序之间的连接不要太过依赖，那样就不方便后期的维护）
//接口是为一批类定义的一个标准,各自有各自的实现方法
//举例
//动物接口,动物都会叫
//但是,狗是狗叫,猫是猫叫...
//所以接口只能定义它会叫（声明）,不能具体到怎么叫（实现）
接只成员特点：
    成员变量:只能是常量并且是静态的
           默认絛饰符public static final
           建议:自己手动给出
    构造方法:接口没有构造方法，因为接口主要是扩展功能，而没有具体存在
    成员方法：只能是抽象方法。
            默认修饰符public abstract
            建议自己手动给出
所有的类都默认继承自一个类: Object.
类Object是类层次结构的根类。每个类都使用Object 作为超类
类与类，
     继承关系, 只能单继承，可以多层继承
类与接口
     实现关系,可以单实现,也可以多实现
     并且还可以在继承个类的同时实现多个接口
接口与接口
     继承关系,可以单继承，也可以多继承
@抽象类和接口的区别:
A:成员区别
     抽象类:成员变量可以变量，也可以常量
           构造方法：有
           成员方法:可以抽象也可以非抽象
     接口：成员变量.只可以常量
         成员方法:只可以抽象
B:关系区别
      类与类:继承单继承
      类与接口：可以实现单实现也可以多实现
      接口与接口：继承.单继承多继承
C:设计理念区别.
   抽象类被继承体现的是，"is a”的关系，   抽象类中定义的是该继承体系的共性功能。
             不同的动物吃的东西应该是不一样的，所以，我们不应该在动物类中给出具体体现，而是应该给出一个声明即可。
             只有看到了具体的动物，你才知道，这是什么动物。所以说， 动物本身并不是一个具体的事物，
             而是一个抽象的事物。只有真正的猫，狗才是具体的动物。
   接口被实现体现的是: "like a”的关系，  接口中定义的是该继承体系的扩展功能。（它本身并不具备，随着。。。发展，它里面添加了新东西）（USB接口）
             猫能跳高，一般来说，跳高这个动作，运动员可以，猫就像一个运动员了，但它不是一个运动员








 */

public class 接口 {
}
